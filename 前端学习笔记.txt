	2022.3.1
*标签快捷键 ：比如 p+table   <p></p>
*代码全体格式化：ctrl+alt+L
*注释：单行：ctrl+/
             多行：ctrl+shift+/
*<hn> 标签 表示标题(n为1-6 ，其中标题从大到小)
*<br/>单标签换行
*<hr/>水平线标签 ——————<hr align="center" width="300px" size="10px " color="green"/>
*<span> 代表无语义标签（代码块）用于css管理
*<div>与span差不多 但可以换行
*&nbsp； html语言中加空格
*<img/> 注意:单标签，必须要有属性src:图片地址 ； alt:当图片未能正常显示时 ，提供给用户的提示信息 ；title:鼠标经过图片时加载的标题
*<a> 标签 表示超链接： <a href=""></a> 1.必须有属性href   2.网站类型地址 必须以 http://开头  3.本地链接必须要有后缀 
				4.target:_blank 在新窗口打开 _self:在本窗口打开
					!!!!!!
					或者自定义 name="**"
					通过超链接 调用target="**"  将链接调用到指定位置
						如：<iframe src="http://www.taobao.com"  width="1000px " height="500px" 							scrolling="auto" name="topiframe" >
    						</iframe>
    							<a href="http://www.sina.com.cn" target="topiframe">点击进入新浪网									</a>
				5.锚定位 用于目录 <h3><a href="#life">个人生活</a></h3>； <h5 id="life">个人生活</h5>

*<ul>:无序列表 注意：1.与其组合的是<li> 其他标签不予组合
		2.<li>是一个可容纳其他元素的标签
                                      <ul type="circle">
        		      <li>
            			<a href=""></a>
        		       </li>
    		</ul>
*<ol>：有序列表  同样与<li>组合
*<dl>:自定义列表 <dl>yeyeye
        		<dd>aa</dd>
        		<dd>cc</dd>
    	            </dl>
*<table>：代表表格
	<caption>代表标题
	<tr> 代表行
	<td>代表单元格或者列 每一行中的元素


2022.3.2


*表单标签（控件）：input
	注意：
		1.input是单标签
		2.input通过type属性来更改它的形状 默认为text   value属性为默认值
*下拉框<select>配合option使用 如：<p>省份：<select name="sel" >
       					 <option selected>请选择省份</option>
        					<option value="浙江" >浙江</option>
        					<option value="江苏">江苏</option>
        					<option value="安徽">安徽</option>
    				</select>
   				 </p>
*label标签 ：提升用户使用体验 ，用户不用非得点击到按钮 而是点击文字即可 如：记住密码
	注意：通过 for 和id绑定
*form表单提交方法：get:不安全 账号密码都在url上 但是速度快
		post:安全 但是速度慢
*文本框输入一些实用属性：1.autofocus:自动获取焦点 即有光标
	                          2.required:防止域为空提交表单
		       3.autocomplete="off" ：不提示历史记录
		       4.placeholder="请输入姓名"：文本框提示
*<details> 配合概括栏<summary> 实现点击概括查看细节
		<details>
        			<summary>lalal</summary>
        				<p>aaaa</p>
    		</details>	
*<progress> 进度条标签 <progress max="100" value="66">进度条</progress>		 
*<video> 视频标签 mp4格式
*<audio>声音标签 mp3/wav格式
*js(javascript) 属性：1.fillStyle 填充绘画颜色，渐变或模式
		2.strokeStyle 用于笔触的颜色，渐变或模式
		3.shadowColor 用于阴影颜色
		4.shadowOffsetX 水平距离偏移量
		5.shadowOffsetY 垂直距离偏移量
		6.shadowBlur 模糊级别
	      方法：1.getContext():返回一个对象 这个方法封装了很多的绘图方法和属性
		但是现在只能提供2d绘画环境
		2.rect();创建矩形
		3.fillRect():绘制填充的矩形
		4.createLinearGradient():绘制线性渐变
		5.addColorStop():渐变对象中颜色和停止位置	


2022.3.3	
 
*6种常用选择器：1.全局选择器*：使用范围最广 优先级最低
	     2.元素选择器 ：一般用于自定义标签上
	     3.类选择器:   .className{ }	如.box{color:red;}
		类名不能以数字开头，一个页面中class名字可以重复
		！！使用最频繁
	     4.ID选择器 ：#idName{ }	如：#box{color:red;}
		一个页面中id相同的id名只能出现一次

		注意; 命名时不要使用中文 ！
	       	优先级：ID选择器>类选择器>元素/标签 选择器>全局选择器
	       5.后代选择器：如 ul li{ color :red;}  表示ul 的后代 li 标签 都采用这个样式
	       6.子代选择器  ul>li{ color:red;} 只表示ul的下一个子代 采用这个样式	
	
*伪类选择器：赋予一些些动画效果
	如1.a:link{} 未访问的链接
	     2.a:visited{} 已访问过的链接
	     3.a:hover{} 鼠标移动到链接上     ！！！比较常用
	    4.a:active{} 鼠标按下时的样式		

2022.3.4

*内边距padding ：表示内容与盒子间距离 简写顺序 （上右下左） 顺时针顺序

*外边距margin ：表示盒子与最外侧距离  简写顺序 （上右下左） 顺时针顺序
 
2022.3.6
*弹性盒子
	父容器属性
		display:flex 默认容器水平布局 ！！声明 是一个弹性盒子
	子容器属性：	
		1.flex-grow:numbe r 每一个子容器占父容器几份 
		如flex-grow:1 表示子容器各占父容器1份   ####很实用 就不用设置每个div的宽度了！！！！
		2.flex-direction:子容器垂直布局

*display属性：
	1.inline-block 行内块元素，即在同一行显示，又可以设置宽高，margin 和padding可以设置四周
	2.block：指定对象为块级元素
	3.inline:转换为行内元素 不能设置宽高
	4.table-cell:指定对象作为表格单元格
	5.none:隐藏对象，不保留物理空间
	6.flex:弹性盒子

*position定位
	1.静态static ：对偏移量不起作用 一般应用于去除定位
	2.相对定位relative：相对于原来自己位置来偏移  通过偏移来移动位置，但是原来所占有位置继续拥有
	3.绝对定位absolute:相对整个浏览器偏移 偏移后不占有原来空间	
	4.固定定位fixed:偏移时固定占位  如右下角广告

2022 3. 7

*常见居中总结：
	1.内容水平居中：
		text-align：center
	2.一行文字垂直居中 高=行高
		line-height =height
	3.盒子水平居中
		例子
			div{
			      width:200px;
			       height:200px;
			       margin:0 auto;			

			}
	4.子元素在父元素中居中：
		1.运用父元素中弹性盒子 display:flex;
			                  align-items:center; 表垂直
				justify-content:center;表水平
*轮播图样式：
.lunbotu{
    width: 100%;
    height: 640px;
    background-image: url("../images/1.jpg");
    /*background-size: cover;*/
    margin-top: 104px;
    -webkit-animation: lunbotu 5s infinite alternate;
}
@-webkit-keyframes lunbotu {
    0%{
        background-image: url("../images/3.png");
    }
    100%{
        background-image: url("../images/2.png");
    }
}	


*阴影：变得立体(很实用！！！)
	1.box-shadow: 15px 15px 10px #9f9f9f;  （浅灰）
	2.	border: 1px solid lightblue;
            		border-radius: 20px;
           	 	box-shadow: 5px 5px 10px skyblue;（天蓝）

	text-shadow:文字阴影同理
	头两个表示偏移量：1.正数  右下角阴影
		              2.负数 左上角阴影  	
	 第三个表示模糊度

*线性渐变
	语法：background:linear-gradient(direction,color-stop1,color-stop2.....)
	默认从上往下渐变


2022 3.8 

*折叠框表示细节：
html结构：

<li class="cart"><a href="#" ><img src="other/images/11.png" width="30px" height="27px"/>购物车(0)</a>
                        <div class="cart_hidden">购物车中还没有商品，赶紧选购吧！</div>
                    </li>

/*这是css样式
.cart_hidden{
    width:350px;
    height:100px;
    line-height: 100px;
    border: 1px solid lightgray;
    background-color: white;
    position: absolute;
    right:45px;
    overflow: hidden;
    top:51px;
    box-shadow:2px 3px 10px gray;
    transition: all .5s;
    display: none;
}
.cart:hover .cart_hidden{
    display: block;
}

2022.3.9 
 
*设置透明度
	opacity:77%

2022.3.10

*设置向上浮动动画
	1.transition: all .3s;
	2.在标签中设置伪类选择器：(hover ) transform:translate(0,-5px);
	
	.wrap2>ul{
    		transition: all .3s;
	}
	.wrap2>ul:hover{
   		 transform: translate(0,-5px);
	}


2020.3.13 (js 开始）
	
	1.当if表达式是负性的时候不能进入分支内容
		js中负性的内容有：null; 空的字符串;undefined(未定义类型);false;0;NAN 
		    表示否定
	2.prompt("提示语句") 会返回一个字符串  默认值可以不写！
	3. console.log() 表示输出
	4.parseInt("字符串") 结果为数字 
		注意：1.如果字符串内以非数字开头  则结果为 NAN  类型为number
		           2. 如果字符串内以数字开头 范式后面含有其他字符 则 只将纯数字部分返回	
		            3. parsetInt() 可以对小数进行取整
	5.当++独立成行 则 再次拿到变量肯定是计算后的值
		如a=1;
		a++（先运算再+1）/++a（先+1 后运算）;
		console.log( a) ;  最后结果都为2	
*----------------------------------------	
<body>
    <div class="div1">
        <div>姓名：<input type="text" id="userName" placeholder="请输入姓名"></div>
        <div>体重：<input type="text" id="userWeight" placeholder="请输入体重(kg)"></div>
        <div>身高：<input type="text" id="userHeight" placeholder="请输入身高(m)"></div>
        <button id="bmi" style="margin-top: 10px">BMI</button>
    </div>
    <div class="div2"></div>
</body>
<script>
    //1.获取界面元素
    var userNameInput=document.getElementById('userName');
    var userWeightInput=document.getElementById('userWeight');
    var userHeightInput=document.getElementById('userHeight');
    var bmiBtn=document.getElementById('bmi');
    var div2=document.getElementById('div2');

    //2.button绑定按钮点击事件
    bmiBtn.onclick=function () {
        //2.1进行逻辑处理
        //获取元素的值
        var userName=userNameInput.value;
        var userWeight=userWeightInput.value;
        var userHeight=userHeightInput.value;

        //体质指数(BMI)=体重(kg)÷身高^2(m)
        var bmi= userWeight/(userHeight*userHeight);
        //当BMI指数为18.5-23.9 为正常
        var result='';
        if (bmi>18.5&& bmi<23.9) {
            result='正常';
        }else{
            result='不正常';
        }

        console.log(userName,userWeight,userHeight,result);
        //将获取的值结果赋值给div2
        div2.innerHTML="您好！"+userName+"您的身高是："+userHeight+"m 体重是："
            +userWeight+" kg BMI指数为：" + bmi+"BMI是："+result;

    }

</script>
*-------------------------------------------

2022.3.15

*js trim():
trim() 方法用于删除字符串的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等。

trim() 方法不会改变原始字符串。

trim() 方法不适用于 null, undefined, Number 类型。
！！例子：
对元素内容判断
                    if (bookName.trim().length==0||bookAuthor.trim().length==0||bookPrice.trim().length==0||bookCount.trim().length==0) {
                        alert("数据不完整");

                    }


*2022.3.18

*undefined： 有申明 但没有赋值

*变量提升：使用var关键字申明的变量 申明语句会被提升到代码的头部（注意：只是申明变量 并没有赋值）

*函数提升：只有采用function申明的函数 才会发生函数提升

*如果不使用var 关键字申明变量 则 此变量为全局变量(所有函数都能调用)

* 调用方法的变量的值 前提需要调用此方法


*2022.3.20

*undefined 和任何数值进行数学运算结果都是NaN  除了字符串拼接

*java中substring的用法

str＝str.substring(int beginIndex);截取掉str从首字母起长度为beginIndex的字符串，将剩余字符串赋值给str；

str＝str.substring(int beginIndex，int endIndex);截取str中从beginIndex开始至endIndex结束时的字符串，并将其赋值给str;

*charAt():获取字符串对应下标的元素

*dom  全称 Document Object Model 文档对象模型
	它是一种用来管理控制html文档的规则
	document 是dom的一个具象化的对象

	document 对象 不需要手动创建 文档加载时 会自动创建
	dom中规定html 页面中的所有元素都是节点

dom的一些属性：
	1.doctype 描述：获取文档的dtd信息
		注意：1.一般情况下，该属性是文档的第一个直接子节点
		            2. 当没有文档类型申明时，返回null


	2.documentElement
		描述：返回html文档
		       注意：1.一般情况下 该属性是文档的第二个直接子节点	
			document.documentElement

	3.body/head
		描述：获取body/head
		语法 document.body/document.head
	
	4.document.documentURI
		描述：返回当前文档的地址
		语法：document.documentURI
		注意：1.所有的文档都具有此属性
		           2.无法在IE浏览器中使用	
	
	5.document.URL
		描述：获取当前文档的地址
		语法：document.documentURL
		注意：html文档独有

	6.document.domain
		描述：获取当前文档的域名
		语法：document.domain
		
	7.document.lastModified
		描述：对文档的最后修改时间
		注意：1.当文档发生修改 最后修改时间 才会改变
	                                2.返回一个字符串类型的时间
		          3.Date.parse('日期字符串') 返回一个毫秒数
	8.location
		常用语句：1.document.location.href("url"); 跳转页面
			2.document.location.reload("")	重新加载资源
						1.true:优先从服务器加载数据
						2.false:优先从本地保存重新加载数据
		
* form 表单提交数据时 一定要写name 属性；
form表单必须使用get方法 才能search到 地址栏的属性值
					

	
*//当文档加载完毕后终止定时器
	var t =setInterval(function()){
		console.log(document.readyState);
	if(document.readyState='complete'){
		console.log('-->'+document.readyState);
		clearInterval(t);

	}
	
	},300);

*querySelector("选择器")
   *选中页面中的一个元素
    *如果有多个元素满足  则返回 第一次出现的元素
    



*2022.3.21

*使用js代码不仅可以创建元素节点 而且可以创建属性节点
	1.document.createElement('p')
	        描述：创建html的元素节点
	        语法：document.createElement('标签名')
	注意：1.创建的元素无法在页面上显示，需要追加到对应的容器中
	            2.appendChild('元素')：将该元素 追加到当前容器所有孩子的后面

	2.创建属性节点
		1.语法：var new=document.createAttribute("属性名")；
			给属性赋值：new.value="color:cyan";
		注意：1.创建的属性节点是一座孤岛  需要和元素产生联系
			通过元素名.setAttributeNode(new)	

下面是一个实例：
	//使用js设置css样式
    //1.创建元素节点
    var p=document.createElement("p");
    //2.将此元素节点添加到body标签中
    document.body.appendChild(p);
    //3.给元素节点添加内容
    p.innerHTML="我房帅呆呆";
    //4.创建属性节点
    var new_1 =document.createAttribute("align");
    //5.给属性赋值
    new_1.value="center";
    var new_2 =document.createAttribute("style");
    new_2.value="color:lightblue";
    //6.最后将元素节点和属性节点连接
    p.setAttributeNode(new_1);
    p.setAttributeNode(new_2);
 



*2022.3.22

*获取指定类名的元素：document.querySelector(".标签类名")/（"#id名"）


2022.3.23

*三大事件：
	1.html事件
		例子：
			<body>
				<p class="p1" onclick="test()">111</p>
				<script>
					function test(){
						console.log("test");
					}
					
				</script>
			</body>

	2.dom0事件
		<body>
				<p class="p2">111</p>
				<script>
					var p2 =document.querySelector(".p2");
					p2.onclick =function(){
						console.log("test1");	
					}
					
				</script>
			</body>
	3.dom2事件
			<body>
				<p class="p3">111</p>
				<script>
					var p3 =document.querySelector(".p3");
					p3.addEventListener("click",function(){
						console.log("test2");

					},true);
					
				</script>
			</body>

*dom2事件绑定
	语法：元素名.addEventListener(事件的类型，函数，是否使用捕获)
	 注意：1.当不写true/false时，dom2事件默认冒泡 false
	            2.dom2事件 可以一次性绑定多个事件，按照绑定的顺序依次执行
	            3.事件流的执行顺序，先执行捕获  事件真正的触发者 先执行捕获还是冒泡 需要看申明 的顺序 再执行冒泡   
	            4.匿名函数无法进行解绑           	
	            5.外部函数或者有名函数可以执行事件的解绑
	                     注意:如果采用事件捕获 解绑时同样需要将true写上         


*解决dom2事件浏览器兼容问题
	//1.定义一个方法
		function addEvent(ele,type,methodName){
			if(ele.addEventListener){//判断如果在非ie浏览器下 是否为正性分支
				ele.addEventListener(type,methodName);
			}else if(ele.attachEvent){判断如果在ie浏览器下 是否为正性分支
				ele.attachEvent("on"+type,methodName);

			}else{
				ele['on'+type]=null;

			}

		
	
		}

2022.3.24

*将dom2事件浏览器兼容问题封装成一个对象（可以单独放到一个文件中供全局使用）
		var tools ={
		         'addEvent':function(ele,type,methodName){
			if(ele.addEventListener){//判断如果在非ie浏览器下 是否为正性分支
				ele.addEventListener(type,methodName);
			}else if(ele.attachEvent){判断如果在ie浏览器下 是否为正性分支
				ele.attachEvent("on"+type,methodName);

			}else{
				ele['on'+type]=null;

			}

			},//属性分隔 用，连接
		            ‘removeEvent':function(ele,type,methodName){
			if(ele.removeEventListener){//判断如果在非ie浏览器下 是否为正性分支
				ele.removeEventListener(type,methodName);
			}else if(ele.detachEvent){判断如果在ie浏览器下 是否为正性分支
				ele.detachEvent("on"+type,methodName);

			}else{
				ele['on'+methodName]=null;

			}
			}	
		};


*滑动div块例子
	<head>
    <meta charset="UTF-8">
    <title>滑动条</title>
    <style>
        .show{
            width: 30px;
            height: 30px;
            line-height: 30px;
            border: 1px solid lightblue;
            position: absolute;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <span>数值</span><input type="range"min="0" max="100" class="range">
    <div class="show"></div>
    <script>
        //1.获取页面元素
            var range=document.querySelector(".range");
            var show=document.querySelector(".show");
        //2.添加事件
            //2.1鼠标按下事件
                range.onmousedown=function () {
                    //1.div显示
                    show.style.display="block";
                    //2.div内有range的值
                    show.innerHTML=range.value;
                    var x=event.clientX;
                    show.style.left=x-15+"px";
                }
                
            //2.2鼠标移动事件
                range.onmousemove=function () {
                    //获取鼠标x坐标
                    var x=event.clientX;
                    //1.范围校验
                        if (x<43){
                            x=43;
                        }else if(x>172){
                            x=172;
                        }
                    //2.div内有range变化的值
                    show.innerHTML=range.value;
                    show.style.left=x-15+"px";
                }
                
            //2.3鼠标抬起事件
                range.onmouseup=function () {
                    //1.div消失
                    show.style.display="none"
                }

    </script>
</body>


*****调色盘例子：
	<head>
    <meta charset="UTF-8">
    <title>调色盘</title>
    <style>
        body{
            background-color: rgb(200,200,200);
        }
    </style>
</head>
<body>
    <p>
        <span>R:</span> <button class="rsub">-</button>
        <input type="text" class="rinput" placeholder="200"/>
        <button class="radd">+</button>
    </p>
    <p>
        <span>G:</span> <button class="gsub">-</button>
        <input type="text" class="ginput" placeholder="200"/>
        <button class="gadd">+</button>
    </p>
    <p>
        <span>B:</span> <button class="bsub">-</button>
        <input type="text" class="binput" placeholder="200"/>
        <button class="badd">+</button>
    </p>
    <button class="go">走</button>

    <script>
        //1.获取页面元素
            var rsBtn=document.querySelector(".rsub");
            var rinput=document.querySelector(".rinput");
            var radd=document.querySelector(".radd");

            var gsub=document.querySelector(".gsub");
            var ginput=document.querySelector(".ginput");
            var gadd=document.querySelector(".gadd");

            var bsub=document.querySelector(".bsub");
            var binput=document.querySelector(".binput");
            var badd=document.querySelector(".badd");

            var go=document.querySelector(".go");

        //定义信号量
            var r=200;
            var g=200;
            var b=200;
             function changeColor(){
                 if (r<0){
                     r=0
                 }if (r>255) {
                     r=255
                 }if (g<0) {
                     g=0
                 } if (g>255) {
                     g = 255
                 } if (b<0) {
                     b=0
                 } if (b>255) {
                     b = 255
                 }
                 rinput.value=r;
                 ginput.value=g;
                 binput.value=b;
                 document.body.style.backgroundColor='rgb('+r+','+g+','+b+')';
             }
        //2.添加绑定事件 7个
        /*红色绑定事件
            */
            rsBtn.onclick=function () {
                //数值减一
                    r--;
                /*//0.数值校验
                if (r<0){
                    r=0;
                }
                //1.输入框的值要改变
                rinput.value=r;
                //2.背景颜色改变
                document.body.style.backgroundColor='rgb('+r+','+g+','+b+')';*/
                changeColor();

            };
            radd.onclick=function () {
                r++;
                /* if (r>255){
                    r=255
                }
                rinput.value=r;
                document.body.style.backgroundColor='rgb('+r+','+g+','+b+')';
            };*/
                changeColor();
            };
            /*绿色绑定事件
            */
            gsub.onclick=function () {
                g--;
               /* if (g<0){
                    g=0
                }
                ginput.value=g;
                document.body.style.backgroundColor='rgb('+r+','+g+','+b+')';*/
                changeColor();
            };
            gadd.onclick=function () {
                g++;
                /*if (g>255){
                    g=255
                }
                ginput.value=g;
                document.body.style.backgroundColor='rgb('+r+','+g+','+b+')';*/
                changeColor();
            };
            /*蓝色绑定事件
            */
            bsub.onclick=function(){
                b--;
               /* if (b<0){
                    b=0
                }
                binput.value=b;
                document.body.style.backgroundColor='rgb('+r+','+g+','+b+')';*/
                changeColor();
            };
            badd.onclick=function () {
                b++;
                /*if (b>255){
                    b=255
                }
                binput.value=b;
                document.body.style.backgroundColor='rgb('+r+','+g+','+b+')';*/

                changeColor();
            };

            go.onclick=function () {
                //1.获取标签的值
                r=rinput.value;
                g=ginput.value;
                b=binput.value;
                /*//2.数值校验
                if (r<0){
                    r=0
                }else if (r>255) {
                    r=255
                }else if (g<0) {
                    g=0
                }else if (g>255) {
                    g = 255
                }else if (b<0) {
                    b=0
                }else if (b>255) {
                    b = 255
                }
                //3.将值赋值给
                rinput.value=r;
                ginput.value=g;
                binput.value=b;
                //4.改变背景颜色
                document.body.style.backgroundColor='rgb('+r+','+g+','+b+')';*/
                changeColor();
            };
    </script>

</body>


**2022.3.25


*去顶部按钮 实例：

<head>
    <meta charset="UTF-8">
    <title>右侧滚动条</title>
    <style>
        .btn{
            position: absolute;
            top:1500px;
            left:100px;
        }
    </style>
</head>
<body>
    <button class="btn">去顶部</button>
    <script>
        var btn=document.querySelector(".btn");
        btn.onclick=function () {
         /* document.documentElement.scrollTop=0;//不需要写单位*/
            //兼容性写法
            var tempTop=document.documentElement.scrollTop || document.body.scrollTop;
            var timer=setInterval(function () {
                tempTop-=150;
                console.log(tempTop);
                if (tempTop<0){
                    clearInterval(timer);
                }
                document.documentElement.scrollTop=tempTop;
            },50);

        };
    </script>
</body>


**2022.3.26


//获取验证码方法
        function getCheckCode(num){
            var str="qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM123456789";
            var result="";
            for (var i=0;i<num ;i++){
                result+=str[Math.floor(Math.random()*((str.length-1)-0+1)+0)];
            }
            return result;
        }
        //当页面一加载完成后 显示验证码
        window.onload=function(){
          var result=getCheckCode(4);
          codeDiv.innerHTML=result;
          
        };


//用户注册例子：

<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .redBorder{
            border:2px solid red;
        }
        .redColor{
            color:red;

        }
        .greenBorder{
            border: 2px solid green;
        }
        .greenColor{
            color: green;
        }
    </style>
</head>
<body>
<p>
    <span>&nbsp;电话：&nbsp;&nbsp;</span>
    <input type="text" name="phone" class="phoneInput">
    <span class="phoneSpan"></span>
</p>
<p>
    <span>用户名：</span>
    <input type="text" name="userName" class="userNameInput">
    <span class="userNameSpan"></span>
</p>
<p>
    <span>验证码：</span>
    <input type="text" name="checkCode" class="checkCodeInput">
    <span class="checkCodeSpan"></span>
</p>
<div class="codeDiv" style="width: 80px;height: 40px; margin-bottom:10px;line-height:40px;background-color: orangered;text-align: center"></div>
<button class="btn" disabled>提交</button>

<script>
    //1.获取页面元素
    var phoneInput=document.querySelector(".phoneInput");
    var phoneSpan=document.querySelector(".phoneSpan");

    var userNameInput=document.querySelector(".userNameInput");
    var userNameSpan=document.querySelector(".userNameSpan");

    var checkCodeInput=document.querySelector(".checkCodeInput");
    var checkCodeSpan=document.querySelector(".checkCodeSpan");
    var codeDiv =document.querySelector(".codeDiv");

    var btnInput=document.querySelector(".btn");


    //绑定验证码失去焦点事件
        checkCodeInput.onblur=function () {
            if (checkCodeInput.value.toUpperCase() == codeDiv.innerHTML.toUpperCase()){
                checkCodeInput.setAttribute("class", "greenBorder");
                //将checkCodeSpan的值设置为正确
                checkCodeSpan.innerHTML = "正确";
                //将checkCodeSpan的颜色设置为绿色
                checkCodeSpan.setAttribute("class", "greenColor");
                checkSuccess();
            } else{
                //将边框设置为红色
                checkCodeInput.setAttribute("class","redBorder");
                //将checkCodeSpan的值设置为错误
                checkCodeSpan.innerHTML="请重新输入验证码";
                //将checkCodeSpan的颜色设置为红色
                checkCodeSpan.setAttribute("class", "redColor");
                checkSuccess();
            }
        };

    //获取验证码方法
        function getCheckCode(num){
            var str="qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM123456789";
            var result="";
            for (var i=0;i<num ;i++){
                result+=str[Math.floor(Math.random()*((str.length-1)-0+1)+0)];
            }
            return result;
        }
        //当页面一加载完成后 显示验证码
        window.onload=function(){
          var result=getCheckCode(4);
          codeDiv.innerHTML=result;

        };
        codeDiv.onclick=function(){
            var result=getCheckCode(4);
            codeDiv.innerHTML=result;
            checkCodeInput.value='';
            checkCodeInput.setAttribute("class","redBorder");
            checkCodeSpan.innerHTML='';
            checkCodeSpan.innerHTML="请重新输入验证码";
            checkCodeSpan.setAttribute("class", "redColor");
            btnInput.setAttribute("disabled","disabled");
        };
    //设置失去焦点事件
        //1.手机号的焦点事件
            phoneInput.onblur=function () {
                console.log("失去焦点");
                if (phoneInput.value.length == 11) {
                    phoneInput.setAttribute("class", "greenBorder");

                    //将phoneSpan的值设置为正确
                    phoneSpan.innerHTML = "正确";
                    //将phoneSpan的颜色设置为绿色
                    phoneSpan.setAttribute("class", "greenColor");
                    checkSuccess();
                }else{
                    //将边框设置为红色
                    phoneInput.setAttribute("class","redBorder");
                    //将phoneSpan的值设置为错误
                    phoneSpan.innerHTML="请输入正确长度手机号";
                    //将phoneSpan的颜色设置为红色
                    phoneSpan.setAttribute("class", "redColor");
                    checkSuccess();

                }
            };
        //2.用户名的焦点事件
            userNameInput.onblur=function () {
                console.log("失去焦点");
                if (userNameInput.value.length >=6 && userNameInput.value.length<=12) {
                    userNameInput.setAttribute("class", "greenBorder");
                    //将userNameSpan的值设置为正确
                    userNameSpan.innerHTML = "正确";
                    //将phoneSpan的颜色设置为绿色
                    userNameSpan.setAttribute("class", "greenColor");
                    checkSuccess();
                }else{
                    //将边框设置为红色
                    userNameInput.setAttribute("class","redBorder");
                    //将phoneSpan的值设置为错误
                    userNameSpan.innerHTML="请输入正确长度用户名";
                    //将phoneSpan的颜色设置为红色
                    userNameSpan.setAttribute("class", "redColor");
                    checkSuccess();

                }
         };

     //判断是否可以提交

     function checkSuccess() {
         if (userNameSpan.innerHTML=="正确"&& phoneSpan.innerHTML=="正确"&&checkCodeSpan.innerHTML=="正确"){
             btnInput.removeAttribute("disabled");
         }else{
             btnInput.setAttribute("disabled","disabled");
         }
     }

</script>
</body>


****this: 谁调用就是谁
	1.html事件绑定中 this 指向window对象
	2.dom0指向真正触发事件的元素
	3.dom2指向真正触发事件的元素
	
**2022.3.28 


 **新闻滚动例子


<head>
    <meta charset="UTF-8">
    <title>新闻滚动条</title>
    <style>
        *{
            margin:0;
            padding: 0;
        }
        .box{
            width: 500px;
            height: 600px;
            border: 1px solid lightblue;
            background-color: lightgray;
            margin: 0 auto;
            position: relative;
            top: 50px;
            overflow: hidden;
        }
        .content{
            padding: 40px;
            position: absolute;
            top: 0;
            left:0;



        }
       .bar{
           width:30px ;
           height:600px ;
           background-color: white;
           position: absolute;
           right: 0;
           top: 0;
       }
        .slidebar{
            width: 30px;
            height: 60px;
            background-color: #0077aa;
            position: absolute;
            right: 0;
            top: 0;
        }.

    </style>
</head>
<body>
<div class="box">
    <div class="content">
        <p>
        4:08 根据《每日体育报》的消息，
        巴萨目前更喜欢拉菲尼亚，他们认为这名前锋的英超经验使他比安东尼更占优势。
        根据此前媒体的报道，利兹联的拉菲尼亚和阿贾克斯的安东尼都在巴萨的考察范围之内。
        《每日体育报》表示，与安东尼相比，目前巴萨更倾向于签下拉菲尼亚。巴萨技术秘书认为
        ，拉菲尼亚有着丰富的英超联赛的经验，在这两个赛季他一直处于一个很高的水平，
        他的速度和无可置疑的技术让他在英超舞台上大放异彩。此外，25岁的他也曾在葡萄牙和法国踢过球，
        他的经验让他更适合巴萨。巴萨想要的是一个能立刻进入首发名单的球员
        ，他们需要在最短的时间内缩小与欧洲竞争对手的差距。的确，打过欧冠是安东尼的优势，
        但是在欧洲联赛方面，他只打过荷甲联赛。
        《每日体育报》指出，巴西国家队正在发生的事情也证明了巴萨的立场是正确的。

        巴西主西主帅蒂特也更喜欢拉菲尼亚，这名利兹联的球员已经在巴西国家队的右翼占据了无可争议的首发位置。

        来源：懂球帝 链接为 www.dongqiudi.com
        </p>
    </div>
    <div class="bar"></div>
    <div class="slidebar"></div>
</div>
<script>
    //获取页面元素
    var box=document.querySelector(".box");
    var content=document.querySelector(".content");
    var bar=document.querySelector(".bar");
    var slidebar=document.querySelector(".slidebar");

    //确定滚动条长度
    var rate=box.clientHeight/content.clientHeight;
    var slideBarHeight=rate * bar.clientHeight;
    slidebar.style.height=slideBarHeight+"px";


    ////三事件一开关
        //1.判断是否移动
        var flag=false;

        var delY=0;
        //2.鼠标按下事件
        slidebar.onmousedown=function (event) {
            var event1=event||window.event;
            flag=true;
            delY=event.clientY-box.offsetTop;
            event1.preventDefault();
        };
        //3.鼠标移动事件
        var tempTop=0;
        box.onmousemove=function (event) {

            if (flag){
                var event=event||window.event;
                 tempTop= event.clientY-delY;
                if (tempTop<0){
                    tempTop=0
                }
                if (tempTop>bar.clientHeight-slidebar.clientHeight){
                    tempTop=bar.clientHeight-slidebar.clientHeight;
                }
                slidebar.style.top=tempTop+"px";
                content.style.top=-tempTop/rate+"px";
            }




        };
        //鼠标抬起事件
            box.onmouseup=function (event) {
                flag=false;
            }

	       //定义函数处理滚轮事件
    function handlerMouseMiddle(event) {
        var event = event || window.event;
        //取消外部联动
        if (event.preventDefault()) {
            event.preventDefault()
        } else {
            event.returnValue = false;
        }
        //判断浏览器类型
        var direction = 0;
        if (event.wheelDelta) {//IE or 谷歌
            direction = event.wheelDelta > 0 ? 1 : -1;
        } else {
            direction = event.detail < 0 ? 1 : -1;
        }

        //向下滚动时
         tempTop += -direction * 20;
        if (tempTop < 0) {
            tempTop = 0
        }
        if (tempTop > bar.clientHeight - slidebar.clientHeight) {
            tempTop = bar.clientHeight - slidebar.clientHeight;
        }
        slidebar.style.top = tempTop + "px";
        content.style.top = -tempTop / rate + "px";
    }

    //ie or Google
    box.onmousewheel=handlerMouseMiddle;
    //火狐
    try{
        box.addEventListener("DOMMouseScroll",handlerMouseMiddle);

    } catch (e) {
    console.log(e);
    }

</script>
</body>


**2022.3.29

1.DOM通过document对象来访问、控制、修改html和html等文档中的内容
2.BOM通过window对象来访问、控制、修改浏览器中的内容
	联系：BOM包含DOM
		浏览器提供用来访问的是BOM对象
		从BOM对象可以访问到DOM对象
	 区别：DOM描述了处理网页内容的方法和接口 即操作页面内容
	            BOM描述了与浏览器进行交互的方法和接口，即操作页面之间


2022.3.31

**原型：js中给函数提供了一个对象类型的属性，叫做原型（prototype）
	作用：1.开辟了一块公共的空间 所有对象都可以访问
		如：Person.prototype.eyesNum=2; 表示Person的公共属性 eyesNum赋值为2
	             2.对象属性值的查找规则  优先在本对象内查找 ，当本对象中没有的时候去原型中查找	

2022.4.1

**JSON解析：
	概述：是一门独立的语言，用于存储和传输数据的格式，通常用于服务端向网页传递数据（数据的载体）
	ps:个人理解JSON就是 
		（1）将前台的数据（对象数组等） 转换成字符串发送给后台
		（2） 将后台回传的数据（字符串） 转换为普通的数据（对象、数组等） 这个转换过程

·主要方法
	JSON.parse(后台传输的数据) 将一个满足json格式的字符串转换为json对象
	JSON.Stringify(要往后台传输的数据) 将一个对象 转为字符串




**2022.4.16

	1.AJAX:
		描述：ajax全称是asynchronos javascript  and xml
			是一种前后端数据交互的手段
		说明：原生的ajax实现比较麻烦 需要借助xmlHttpRequest对象来构建
			一般使用已经封装好的jquery来使用
		说明：
		     	(1)get无参请求：一般用来向后台获取数据使用，不会发送给后台任何内容
			(2)get带参请求：一般像贴吧，社区等需要根据页码或指定属性获取数据使用 
					这种情况下参数比较少
			(3)post请求：一般用于登录，注册等保密性比较高的位置
				$.ajax({
					type:'post',
					url:'',
					dataType:'json'//一般情况都是json数据格式
					data:{	//post请求独有属性
						
					}
					//当后台返回具体数据时，该函数自动执行，用来获取					后台返回的具体数据
					success：function(res){
						console.log(res);
					}
					});



**2022.4.19
前端框架初始
	1.Node:
		 1.Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言,Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。
		2.Node.js 的包管理器 npm，是全球最大的开源库生态系统。
	1.webpack是什么？
		1.webpack构建工具
		2.自带模块化（commonjs规范）
		3.编译：es6 ->es5 ,jsx ->es5,ts(typescript) ->js
		4.gulp所做的事情，webpack都可以做到
		5.自带服务器，服务器也是基于node（webpack-dev-server）
		6.哪些环境经常使用到webpack:  react,  vue
		-----------
		总的来说，webpack能将各种浏览器无法识别的文件，转换成浏览器环境可以识别的文件			（html,js,css）。
		这个转换过程称为构建。
		---------
	2.安装webpack
	        	1.安装全局webpack	
			npm install -g webpack
			npm install -g webpack-cli@2.x
		2.项目初始化package.json
			npm init -y  全是默认yes
		3.安装项目依赖的webpack
			npm install -D webpack@3.x(得在项目目录下安装)
		4.项目根目录创建两个文件夹src和dist
			src:源码文件
			dist:编译后的文件
		5.在src文件夹下新建一个js文件并编写代码
			document.write("hello webpack");
		6.执行webpack
			webpack 入口文件 出口文件
		7.编写代码
			hello.js
				module.exports=function () {
    				var hello =document.createElement("div");
    				hello.textContent="hello webpack";
    				return hello;
				};

	3.生成webpack.config.js文件
		1.配置出口入口
			module.exports={
 				 entry:__dirname+"/src/app.js",
  				output:{
      					path:__dirname+"/dist",
     					 filename:"test.js"
 					 }
				};	
	4.webpack执行的快捷方案
		在package.json文件中代替webpack的执行
		"scripts": {
   		 "build": "webpack"
  		},
		命令：npm run build
	5.调试:
		生成错误信息文件
			配置webpack.config.js文件
			添加devtool:"eval-source-map"
---2022.4.21
	6.服务器
		1.全局安装服务器
			npm install -g webpack-dev-server@2.x
		2.安装项目依赖
			npm install -D webpack-dev-server@2.x
		3.运行webpack 服务器
			webpack-dev-server
		4.配置服务器
			"scripts": {
    				"build": "webpack",
    				"dev": "webpack-dev-server"
 				 },
			命令：npm run dev
		5.修改服务器根路径
			"dev": "webpack-dev-server --content-base /dist"
		6.热更新（不需要重启服务器 根据修改代码自动更新）
			"dev": "webpack-dev-server --content-base dist --inline --hot"
		7.服务器配置
			--content-base:指定服务器运行根目录
			-- inline:在线更新
			--port:修改端口 
				 "dev": "webpack-dev-server --content-base dist --inline 						--hot --port=8081"

	7.module
		loader(use)
		loader 是weback 可以通过配置脚本，或者外部依赖来执行一些功能
			例如：es6 ->es5  jsx->js  less ->css 
		1.配置loaders
			1.test:一个匹配loader要做操作的文件的一个正则表达式（必须）
			2.loader:loader要执行的任务的名字（必须）
			3.options：为loader提供一些外部选项配置（可选项）
		2.json格式的数据转换成js对象
			注意：当前的json-loader 只是为了测试我们当前安装的webpack的版本
				其实，在当前版本中已经集成了json-loader
			1.安装json-loader
				npm install -D json-loader	
			2.编写配置文件代码
				{
					test:/\.json$/,
					use:"json-loader"
				}	
	8.es6 ->es5
		1.安装依赖
		npm install -D babel-core babel-loader@7 babel-preset-es2015
		ps:注意！：
			babel-loader 7.x | babel 6.x
			babel-loader 8.x | babel 7.x
			否则版本不兼容无法运行服务器
		2.配置webpack
			 {
               				 test:/\.js$/,
                				use:"babel-loader"
        
           			 }
	-----2022.4.22
		
	9.构建react环境（webpack+es6+react）
		1.安装react
			npm install --save react react-dom
			npm install --save-dev babel-preset-react
		2.编写配置文件
			{
               				 test:/\.(js|jsx)$/,
                				use:"babel-loader"
           			 }
			增加.babelrc文件
	10.css和图片处理
		1.安装css相关依赖
			1.npm install -D css-loader style-loader
			2.npm install -D file-loader url-loader
		2.添加配置
			2.1css配置
			{
               				 test:/\.css$/,
                					use:[
                    				"style-loader",
                    				"css-loader"
                					]
           			 }
			2.2图片配置
			{
               				 test:/\.(png|jpg|gif|jpeg|svg)$/,
                				use: "url-loader?limit=2048" //大于2M进行压缩
           			 }
	----2022.4.23
	11.less和Sass
		1.安装：
			npm install --save-dev less less-loader
		2.添加配置
			 {
               				 test:/\.less$/,
                				use:[
                    			"style-loader",
                   			 "css-loader",
                    			"less-loader"
                				]
           			 }
	12.插件（plugins）
		1.打开浏览器
			1.安装：
			npm install -D open-browser-webpack-plugin
			2.配置
		2.html模板添加
			1.安装：
			npm install -D html-webpack-plugin
			2.配置
		3.内置插件（省略后缀名）
			resolve:{
        				extensions:['.js','.jsx']
    			},
	14.生产环境的搭建
		npm install -D cross-env
		npm install -D babel-plugin-react-transform
		npm install -D react-transform-hmr
	
--2022.4.24
	React初始：
		1.React是什么?
    A JavaScript library for building user interfaces
    用户视图！！
    最开始，很多人说React是MVC中的v 总结React就是一套为视图而准备的js框架
    React由facebook打造的 致力于DOM渲染 更易于维护的DOM层
    jsx语法：由javascript+xml语言组成 其中xml相当于html语言
            -遇到{}按照js语法解析
            -遇到<>按照xml语法解析
            
            warning:每一个列表元素需要指定一个key作为该元素的索引
            
            组件：
                   在React中，整体是一个组件化设计
                   1.创建组件时命名首字母必须大写
                   2.组件中只能存在一个根容器
                   3.组件与组件之间可以互相嵌套
                   4.组件本身可以具有业务逻辑
                   5.组件数据交互:props 
                        this.props.属性名
                        数据传递
                   6.组件内部状态改变：state（组件内状态改变）
                        1.this.state.属性名   
                        2.this.setState({})  
		setState():引起视图的重建
                   7.组件加样式
                        类命名 className=""
                        行内样式 style={{}} 两个花括号 因为style 接收的是一个对象
                            如：<span style={{color:'green',fontSize:'35px'}}>lalalal</span>
	       添加事件  同样是onclick={} 如 <button onMouseOver={this.hander}>按钮</button>

-----2022.4.25
	8.组件（component）的生命周期: 
		组件将要挂载时触发的函数：componentWillMount
		组件挂载完成时触发的函数：componentDidMount
		是否要更新数据时触发的函数：shouldComponentUpdate
		将要更新数据时触发的函数：componentWillUpdate
		数据更新完成时触发的函数：componentDidUpdate
		组件将要销毁时触发的函数：componentWillUnmount
		父组件中改变了props传值时触发的函数：componentWillReceiveProps

--2022.4.26
	react脚手架:
		命令：
			1.npm install -g create-react-app	
			2.并在文件夹下面cmd：create-react-app 项目名称
		
		*语法糖
			jsx就是javascript新的语法糖（jsx->最终要编译成javascript）
			typescript也是javascript的语法糖

			
			
	
			
			
			

		
